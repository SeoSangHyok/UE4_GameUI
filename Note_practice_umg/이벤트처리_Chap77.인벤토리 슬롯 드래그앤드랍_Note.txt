1. 자손위젯에 버튼이 있을경우 버튼의 OnClicked이벤트와 위젯의 OnMouseButtonDown 이벤트는 같이 사용할경우 한쪽에서 이벤트를 모두 먹어버리기때문에 같이 사용할수 없다.

2. 이경우 마우스 처리 함수를 오버라이딩해서 직접 클릭처리를 해야한다.

3. 수동으로 마우스 입력처리를 할경우 위젯의 IsFocusable을 켜주는것이 좋다.

4. 마우스 우클리과 좌클릭 모두 지원하는 위젯에서 UWidgetBlueprintLibrary::DetectDragIfPressed 로 드래그를 처리하는 경우 드래그를 감지하는 마우스 버튼이외의 동작이 먹지 않는 현상이 있다.
   (예를 들어 마우스 좌우 클릭 모두 지원하는 위젯에서 DetectDragIfPressed함수를 마우스 좌클릭으로 처리하면 우클릭이 안먹는다. 반대의 경우도 마찬가지)

5. 영상에선 직접 드래그를 구현하는 방식으로 처리했지만. 개인적으로는 DetectDragIfPressed함수를 그대로 사용해서 처리하려고 한다.
  - Drag를 마우스 좌클릭으로만 처리한다면 DetectDragIfPressed를 좌클릭 처리가 되었을때만 처리
  - 만약 좌우 버튼 드래그를 모두 지원하는경우 좌우 클릭에 따라 DetectDragIfPressed처리를 한다.
  - 어느 상황이되었던 버튼클릭의 우선순위와 버튼클릭이벤트를 처리할 조건을 명확하게 하는것이 중요
    (나같은 경우는 버튼 클릭동작은 두 버튼 상황이 모두 클리어 할경우 이벤트를 처리, 우선순위는 좌클릭>우클릭)

6. 영상에서 수동처리는 다음과 같이 처리했다.
  - 마우스 좌클릭시 좌표 저장
  - 마우스 이동 이벤트 발생시 마우스 좌클릭 상태 + 저장해둔 좌표와 차이가 난경우 드래그 처리
  - 드래그 처리는 UWidgetBlueprintLibrary::DetectDrag() 함수를 이용
  - 이와같이 처리하면 동일하게 OnDetectDrag가 호출
  - 버튼 상태를 모두 초기화

7. OnDrop의 경우 헨들링되지 않는 위젯에서는 false 반환되며 false가 반환된 경우 다음 위젯으로 이벤트를 넘긴다. 
