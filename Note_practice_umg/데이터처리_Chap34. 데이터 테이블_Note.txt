1. BP에서 csv파일등을 이용한 데이터 테이블을 구축하려면 우선 블루프린트 구조체를 먼저 정의해야한다.

2. 네이티브 환경으로 데이터 테이블을 구축할경우 따로 테이블 구조체를 코드로 정의해야한다.
  - 빌드할때 언리얼 헤더툴에서 구조체를 인식할수 있도록 하기위해 에디터에서 빈 Object 클래스를 하나 생성한다. Object 클래스를 상속받게 하는게 깔끔하고 좋다.
  - 생성한 클래스에 FTableRowBase 를 상속받은 구조체를 정의. 아래 처럼 정의하면 된다.
      USTRUCT(BlueprintType)
      struct FXXXXX : public FTableRowBase // 언리얼 네이밍 규칙은 구조체에는 F로 시작하는 네이밍을 붙인다.(오브젝느는 U, 엑터는 A로 시작)
      {
        GENERATED_USTRUCT_BODY()

        public:
          FXXXXX(){}

        // 테이블 변수 설정
      }

  - 위와같이 설정하면 빌드후 에디터에서 테이블 베이스 구조체로 선택가능
  - 그후 데이터테이블에셋을 생성, 테이블을 정의하면 끝.

3. 구조체와 비슷하게 열거형(enum도) 네이티브환경에서 정의 가능.
  - 빌드할때 언리얼 헤더툴에서 열거형을 인식할수 있도록 하기위해 에디터에서 빈 Object 클래스를 하나 생성한다. Object 클래스를 상속받게 하는게 깔끔하고 좋다.
  - 생성한 클래스헤더에 아래처럼 열거형 등록
      UENUM(BlueprintType) // BP확장없이 네이티브로 사용할경우 BlueprintType 은 없어도 된다.
      enum class EItemEquipSlot : uint8
      {
      	// 열거형 값 설정
      };

4. 구조체 테이블을 맴버에 메시나 파티클같은 에셋을 정의할경우 에셋의 레퍼런스를 정의하는 일이 없도록 할것. 에셋 레퍼런스로 정의하면 해당 테이블데이터를 사용하지 않더라도
   테이블 로드시 무조건적으로 에셋을 메모리에 올리는 불상사가 발생한다.
   테이블 정의시 BP에선 에셋이나 클래스 에셋 ID를 네이티브에선 FSoftObjectPath나 FSoftClassPath를 사용해서 정의하자

5. 데이터테이블에셋의 행(Row)검색 키는 스트링형식(FName일듯.. 언리얼에서 FName은 내부적으로 해싱되어 번호로 처리가 가능하기때문)으로 정의된다. 그러므로 행이름은 절대로 중복되지 않도록 하는것이 중요.
   추가로 행이름은 따로 확인이 어렵기 때문에 구조체 맴버에 행 이름에 매칭되는 맴버를 넣어주는것이 팁

6. 에셋데이터는 csv파일을 이용해서 대량으로 데이터를 추가하는것이 가능
   - csv파일의 첫번째열은 데이터테이블에셋의 키값. 즉 행이름이여아함.
   - 그뒤로 테이블 구조체에 정의된 맴버이름을 순서대로 넣는다.
   - 테이블 맴버는 설정값 텍스트를 그대로 넣어주면 임포트할때 언리얼이 알아서 파싱해주니 편리~
   - 테이블에 에셋을 매칭시킬때는 매칭시킬 에셋 - [우클릭] - [에셋레퍼런스복사] 후 그대로 붙여넣기 해주면 끝
   - 여담으로 이렇게 테이블을 이용해서 처리하는것을 데이터드리븐 이라고 하며 게임 개발시 아주 중요하니 정말 특별한 사항이 아닌이상 데이터 드리븐이 가능하도록 게임을 제작할것!!

7. 기획테이블은 엑셀이 주로 사용되는데 엑셀 안에 참고용 메모등 필요하지 않은 맴버를 넣는경우가 많다. 그런이유로 메크로를 이용해 필요한 행과 열만 뽑아내서 csv를 만드는것이 좋다.
   - 관련 언리얼 문서 링크 남겨둔다.
     http://api.unrealengine.com/KOR/Gameplay/DataDriven/

8. 테이블 에셋은 여러군대 로드할 필요가 없기때문에 싱글톤같은 단일 객체를 두고 해당 객체에서만 읽어오는게 좋다. 만일 각 액터마다 에셋 데이터를 메모리에 들고있으면 메모리 낭비가 심할것
   언리얼에서도 싱글톤 클래스를 생성할 수 있다. 참고링크 남겨둔다.
   https://wiki.unrealengine.com/Global_Data_Access,_Data_Storage_Class_Accessible_From_Any_CPP_or_BP_Class_During_Runtime

9. 2014년도에 언급된 내용이긴한데 싱글톤 보다는 GameInstance활용을 더 권장하는듯 하는 내용을 봤다.
   https://forums.unrealengine.com/development-discussion/c-gameplay-programming/13647-game-instance-vs-singleton?29765-Game-Instance-VS-Singleton=
   내용인즉 에디터에서 실행시 게임인스턴스는 각 PIE세션마다 하나씩 생성하는데 비해 싱글톤은 단 하나만 생성되며 각 PIE세션이 모두 공유하는 방식이라는 내용.
   어자피 객체수명은 거의 동일하니 게임인스턴스에 정의하는것이 어떨까한다.

10. 에디터에서 게임인스턴스를 활용시 문제가 하나 있는데 에디터 상에서는 게임 인스턴스가 생성되지 않는 문제가 있다.(에디터 상에서 PIE로 실행하면 게임인스턴스가 항시 null로 온다.)
   엔진소스중 UOnlineEngineInterface에 싱글턴 및 스테틱 오브젝트 처리가 있어서 해당 코드를 참고해서 테이블 로더 구현.
   개인적 생각이지만 싱글턴 보단 게임인스턴스를 사용하고 인스턴스에서 싱글턴 오브젝트를 관리할수 있도록 처리하는게 좋을거 같다. 물론 이와같이 하면 게임인스턴스가 비대화 될 가능성도 있지만
   싱글턴 클래스의 비정상(?)동작방식과 게임오브젝트의 흐름 그리고 관리의 명확함들 생각한다면 실보다 득이 많다고 보인다.
